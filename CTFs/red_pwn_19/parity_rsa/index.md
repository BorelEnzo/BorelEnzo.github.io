# 0100100100100... - Crypto

### [~$ cd ..](../)

> 010000100110100101101110011000010111001001111001
>
>Written by: Tux
>
>0100100100100000011001100110111101110101011011100110010000100000011101000110100001101001011100110010000001110111011001010110100101110010011001000010000001110011011001010111001001110110011010010110001101100101001011100010111000101110
>
> nc chall2.2019.redpwn.net 5001
>
>Hint: 010010010111001100100000011010010111010000100000011001010111011001100101011011100010000001101111011100100010000001101111011001000110010000111111

The name of this challenge was actually `010000100110100101101110011000010111001001111001`, or `Binary` once decoded. The description tells us (once decoded): `I found this weird service...`

By connecting to the service, we were given this kind of binary strings:

```
$ nc chall2.2019.redpwn.net 5001
011101010110110001110100011010010110110101100001011101000110010100100000011001010110111001100011011100100111100101110000011101000110100101101111011011100010000001110011011001010111001001110110011010010110001101100101

0101011101000001010100100100111001001001010011100100011100111010001000000100100100100000011011110110111001101100011110010010000001110011011000010111100100100000001100000010000001101111011100100010000000110001

0010100001001110001011000110010100101001: (1010000010101001010100011001000101100111001001111011111001110110100100101001101110100001011011011110000111010100010010100100010110101010011111101011110001101011011010001111011101000110011010000000110110010100110011110011010111100011000111010010110010110110001111010101001000111101100100000101001111111100101010111000011001101100001100100111111000111101001100011011000110000001100111011001101000100001001011100110100111010001001111111100010101100100001001010011100100000110110010110100001001110011111101001001010001011101110001001001001000011111000010010110100000000001000011000001000100111001100010011110111100001100100001100100001110111110001110001010010100101001101100110111100011011101100011000101100001010100101000111001010000000000000010011000001101001010001111011011110100111010111100101000110011010011001000110011000100111011111101001100010001101111110110110111001101111110111001010001101101001101101001001000010100000101001110001000100010111111010110010011010011000000111001001101101000101111011011110000110001100111, 10000000000000001)

0100010101001110010000110101001001011001010100000101010001000101010001000010000001001101010001010101001101010011010000010100011101000101: 110000000100100011001111001001010001101011110001001000010110001011011101000001001010011011010100001000010101000110000100100111100011001001000111111001001000001010100000100100001000000001010111011110101110110011011010111010100101001010011001001111101011011010010001001001001001111010001111111010100001100101101110100101110110101001000100010111010110100010000001000010111101000011011010110101110001101111110010000001001111011100100001100101001010001100100111011100101111000111111110000100001111001010010011010110001110011101101111010110110101110100000101111101101001011101111010011100110001010010111010110011011111100111011010111000110101010100101110110011110010011011011100011011111000000011111000101110110101011001110101110101010010010000001110101001110011111110101011111100010100001011001110101010101111110000001100101111100110010100010000001000010010001001001100001111101111101001010100100110000000111110110001010010100010100000111011011100110101011011000000111001011001010000011110100000011000001000110110110110111001111
```

By decoding them, we found:

```
ultimate encryption service

WARNING: I only say 0 or 1

(N,e):
(112820272420637156979158172331628330297232628038420754084490147382395308412898856875390910933117289487104503898289423862703383101325661015770582170131306181470329418124549394443058171187296058141496029544625348857682550320502745597751425463218136038837821119291458387800445018946499143013599479306631672433767L, 65537)

ENCRYPTED MESSAGE:
67513352578518453979087070786548427945402159735402919105012791737104293809665908001647430186669751938752966420062819618940599365597299105985416021134663977640728434772072955978847876157266297845970487158470075069403813982568118720085334149816706491107958193490886781372310416279923723978628245732034285891023L
```

The modulus and the ciphertext were apparently not always the same.
By decoding the hint in the same way, we got `Is it even or odd?`, then it was quite obvious that it was about LSB oracle attack on RSA. This attack is quite unlikely in the real world, as it assumes that an oracle will decrypt a ciphertext and return its parity. However, it's a quite common challenge in CTFs.

In a nutshell, the principle is to query the oracle so as to reduce the interval where the plaintext lies. As a reminder, the modulus N is the product of two big random prime numbers, making it really hard to factorize.
Since these two factors are prime, there are also odd (except if there are equal to 2, but for obvious reasons, it's REALLY unlikely).

Then, even if the plaintext `m` is unknown, we know that `2m` is even. Once taken modulo `N`, there are two possibilities:

* if `2m < N`, the modulo doesn't apply, and `2m % N = 2m` (still even, returns 0)
* otherwise, the modulo operation makes the result odd, as `N` is odd and greater than `m` (returns 1)

By dividing by two on both sides, we can conclude that:
* parity equal to 0 implies that `2m < N => m < N/2`
* parity equal to 1 implies that `2m > N => m > N/2`

It then looks like a divide-and-conquer approach, and we can continue until finding a unique value in the interval. The next step would be to send `4m` to the oracle.

Let's suppose that the first answer was 0:
* if the answer is still 0, then `4m < N => m < N/4` (modulus doesn't apply).
* if the answer is 1, then it means that `m > N/4`, and `m < N/2` from the first iteration

Let's suppose that the first answer is 1:
* if the answer is 0, then we use `2(2m - N)` as `2m` was already bigger than `N`. Then it comes that:  
`=> 2(2m - N) < N`  
`=> 2m - N < N/2`  
`=> 2m < 3N/2`  
`=> m < 3N/4` and from the first iteration, we also know that `m > N/2`
* if the answer is 1, then `m > 3N/4`, and the upper bound is still `N`

Many scripts performing this attack exist in the wild, and we only had to tweak one of them (for ex: [this one](https://hack.more.systems/writeup/2016/12/18/sharifctf-lsb-oracle/)).

The script we finally used was this one:

```python
from Crypto.Util.number import *
from Crypto.PublicKey import RSA
from pwn import *

def _decrypt(ciphertext):
    r.sendline(bin(ciphertext)[2:])
    print ciphertext
    pt = r.recvline()[1:-1]
    print pt
    print r.recvuntil(">")
    return int(pt)

r = remote("chall2.2019.redpwn.net", 5001)
data = r.recvuntil(">")
print data
N = int(data[data.find("(")+1:data.find(",")],2)
flag_enc = int(data[data.rfind(": ")+2:-2],2)
print N
print flag_enc
e = 65537

UP = N
LOW = 0

cur_C = flag_enc
for i in range(N.bit_length()):
    cur_C = (cur_C * (2**e % N)) % N
    if _decrypt(cur_C) == 0:
        UP = (UP + LOW)/2
    else:
        LOW = (UP + LOW)/2

pt =  long_to_bytes(UP)
print pt
```

In the end, the script returned `flag{y0u_s0lved_th3_l3ast_s1gn1f1c1nt_RSA!-1123|ï¿½`, and we guessed that the correct flag was **flag{y0u_s0lved_th3_l3ast_s1gn1f1c1nt_RSA!-1123}**

EOF
