# Chop Suey

### [~$ cd ..](../)

I really love crypto, and for once, we are not given N,e and c!:

>p = 8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229
>q = 12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469
>dp = 6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929
>dq = 783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041
>c = 2472230540388738207356731646764908066263155290596022939907910799560215441817605633580063888752761416407353043765708507967615735020535194522298935131607648

The goal here was to use the chinese remainder theorem to decrypt the ciphertext, and we have all we need to do this:

* p and q are the two factors such that p*q = N
* dp = 1/e mod (p-1)
* dq = 1/e mod (q-1)

d can be written as a multiple of phi(p) = p-1 plus a remainder:

> ```
> d = k * phi(p) + (d mod phi(p))
> => c^d = c^{k * phi(p) + (d mod phi(p))}
> => 	 = c^{k * phi(p)} * c^{d mod phi(p)}
> => 	 = c^{phi(p)^k} * c^{d mod phi(p)}
> ```

Since c^phi(p) mod p = 1 (Euler's theorem), we have

> ```
> => c^d =  c^{d mod phi(p)}
> ```
Because of the CRT, we know that we had to find a number m such that:

>m = (c^d mod N) mod p
>m = (c^d mod N) mod q

Thanks to Garner's formula, it's quite simple:

> ```python
>p = 8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229
>q = 12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469
>from Crypto.Util import number
>qInv = number.inverse(p,q)
>c = 24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852
>dp = 6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929
>dq = 783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041
>m1 = pow(c, dp, p)
>m2 = pow(c, dq, q)
>h = (qInv * (m1 - m2)) % p
>m = m2 + h * q
>print hex(m)[2:-1].decode('hex')
> ```

And we got: **noxCTF{W31c0m3_70_Ch1n470wn}**
