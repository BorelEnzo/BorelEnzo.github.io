package myjava.awt.datatransfer;

import java.io.ByteArrayInputStream;
import java.io.CharArrayReader;
import java.io.Externalizable;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.ObjectOutput;
import java.io.Reader;
import java.io.Serializable;
import java.io.StringReader;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.charset.Charset;
import java.nio.charset.IllegalCharsetNameException;
import java.util.Arrays;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import org.apache.harmony.awt.datatransfer.DTK;
import org.apache.harmony.awt.internal.nls.Messages;

public class DataFlavor
  implements Externalizable, Cloneable
{
  public static final DataFlavor javaFileListFlavor;
  public static final String javaJVMLocalObjectMimeType = "application/x-java-jvm-local-objectref";
  public static final String javaRemoteObjectMimeType = "application/x-java-remote-object";
  public static final String javaSerializedObjectMimeType = "application/x-java-serialized-object";
  @Deprecated
  public static final DataFlavor plainTextFlavor = new DataFlavor("text/plain; charset=unicode; class=java.io.InputStream", "Plain Text");
  private static DataFlavor plainUnicodeFlavor = null;
  private static final long serialVersionUID = 8367026044764648243L;
  private static final String[] sortedTextFlavors;
  public static final DataFlavor stringFlavor = new DataFlavor("application/x-java-serialized-object; class=java.lang.String", "Unicode String");
  private String humanPresentableName;
  private MimeTypeProcessor.MimeType mimeInfo;
  private Class<?> representationClass;
  
  static
  {
    javaFileListFlavor = new DataFlavor("application/x-java-file-list; class=java.util.List", "application/x-java-file-list");
    sortedTextFlavors = new String[] { "text/sgml", "text/xml", "text/html", "text/rtf", "text/enriched", "text/richtext", "text/uri-list", "text/tab-separated-values", "text/t140", "text/rfc822-headers", "text/parityfec", "text/directory", "text/css", "text/calendar", "application/x-java-serialized-object", "text/plain" };
  }
  
  public DataFlavor()
  {
    this.mimeInfo = null;
    this.humanPresentableName = null;
    this.representationClass = null;
  }
  
  public DataFlavor(Class<?> paramClass, String paramString)
  {
    this.mimeInfo = new MimeTypeProcessor.MimeType("application", "x-java-serialized-object");
    if (paramString != null) {}
    for (this.humanPresentableName = paramString;; this.humanPresentableName = "application/x-java-serialized-object")
    {
      this.mimeInfo.addParameter("class", paramClass.getName());
      this.representationClass = paramClass;
      return;
    }
  }
  
  public DataFlavor(String paramString)
    throws ClassNotFoundException
  {
    init(paramString, null, null);
  }
  
  public DataFlavor(String paramString1, String paramString2)
  {
    try
    {
      init(paramString1, paramString2, null);
      return;
    }
    catch (ClassNotFoundException paramString1)
    {
      throw new IllegalArgumentException(Messages.getString("awt.16C", this.mimeInfo.getParameter("class")), paramString1);
    }
  }
  
  public DataFlavor(String paramString1, String paramString2, ClassLoader paramClassLoader)
    throws ClassNotFoundException
  {
    init(paramString1, paramString2, paramClassLoader);
  }
  
  private static List<DataFlavor> fetchTextFlavors(List<DataFlavor> paramList, String paramString)
  {
    LinkedList localLinkedList = new LinkedList();
    paramList = paramList.iterator();
    for (;;)
    {
      if (!paramList.hasNext())
      {
        paramList = localLinkedList;
        if (localLinkedList.isEmpty()) {
          paramList = null;
        }
        return paramList;
      }
      DataFlavor localDataFlavor = (DataFlavor)paramList.next();
      if (localDataFlavor.isFlavorTextType())
      {
        if (localDataFlavor.mimeInfo.getFullType().equals(paramString))
        {
          if (!localLinkedList.contains(localDataFlavor)) {
            localLinkedList.add(localDataFlavor);
          }
          paramList.remove();
        }
      }
      else {
        paramList.remove();
      }
    }
  }
  
  private String getCharset()
  {
    Object localObject;
    if ((this.mimeInfo == null) || (isCharsetRedundant())) {
      localObject = "";
    }
    String str;
    do
    {
      return (String)localObject;
      str = this.mimeInfo.getParameter("charset");
      if ((isCharsetRequired()) && ((str == null) || (str.length() == 0))) {
        return DTK.getDTK().getDefaultCharset();
      }
      localObject = str;
    } while (str != null);
    return "";
  }
  
  private static List<DataFlavor> getFlavors(List<DataFlavor> paramList, Class<?> paramClass)
  {
    LinkedList localLinkedList = new LinkedList();
    Iterator localIterator = paramList.iterator();
    for (;;)
    {
      if (!localIterator.hasNext())
      {
        if (localLinkedList.isEmpty()) {
          paramList = null;
        }
        return paramList;
      }
      DataFlavor localDataFlavor = (DataFlavor)localIterator.next();
      if (localDataFlavor.representationClass.equals(paramClass)) {
        localLinkedList.add(localDataFlavor);
      }
    }
  }
  
  private static List<DataFlavor> getFlavors(List<DataFlavor> paramList, String[] paramArrayOfString)
  {
    LinkedList localLinkedList = new LinkedList();
    Iterator localIterator = paramList.iterator();
    for (;;)
    {
      if (!localIterator.hasNext())
      {
        if (localLinkedList.isEmpty()) {
          paramList = null;
        }
        return paramList;
      }
      DataFlavor localDataFlavor = (DataFlavor)localIterator.next();
      if (isCharsetSupported(localDataFlavor.getCharset()))
      {
        int j = paramArrayOfString.length;
        int i = 0;
        while (i < j)
        {
          if (Charset.forName(paramArrayOfString[i]).equals(Charset.forName(localDataFlavor.getCharset()))) {
            localLinkedList.add(localDataFlavor);
          }
          i += 1;
        }
      }
      else
      {
        localIterator.remove();
      }
    }
  }
  
  private String getKeyInfo()
  {
    String str = this.mimeInfo.getFullType() + ";class=" + this.representationClass.getName();
    if ((!this.mimeInfo.getPrimaryType().equals("text")) || (isUnicodeFlavor())) {
      return str;
    }
    return str + ";charset=" + getCharset().toLowerCase();
  }
  
  public static final DataFlavor getTextPlainUnicodeFlavor()
  {
    if (plainUnicodeFlavor == null) {
      plainUnicodeFlavor = new DataFlavor("text/plain; charset=" + DTK.getDTK().getDefaultCharset() + "; class=java.io.InputStream", "Plain Text");
    }
    return plainUnicodeFlavor;
  }
  
  private void init(String paramString1, String paramString2, ClassLoader paramClassLoader)
    throws ClassNotFoundException
  {
    for (;;)
    {
      try
      {
        this.mimeInfo = MimeTypeProcessor.parse(paramString1);
        if (paramString2 != null)
        {
          this.humanPresentableName = paramString2;
          paramString2 = this.mimeInfo.getParameter("class");
          paramString1 = paramString2;
          if (paramString2 == null)
          {
            paramString1 = "java.io.InputStream";
            this.mimeInfo.addParameter("class", "java.io.InputStream");
          }
          if (paramClassLoader != null) {
            break label122;
          }
          paramString1 = Class.forName(paramString1);
          this.representationClass = paramString1;
          return;
        }
      }
      catch (IllegalArgumentException paramString2)
      {
        throw new IllegalArgumentException(Messages.getString("awt.16D", paramString1));
      }
      this.humanPresentableName = (this.mimeInfo.getPrimaryType() + '/' + this.mimeInfo.getSubType());
      continue;
      label122:
      paramString1 = paramClassLoader.loadClass(paramString1);
    }
  }
  
  private boolean isByteCodeFlavor()
  {
    return (this.representationClass != null) && ((this.representationClass.equals(InputStream.class)) || (this.representationClass.equals(ByteBuffer.class)) || (this.representationClass.equals(byte[].class)));
  }
  
  private boolean isCharsetRedundant()
  {
    String str = this.mimeInfo.getFullType();
    return (str.equals("text/rtf")) || (str.equals("text/tab-separated-values")) || (str.equals("text/t140")) || (str.equals("text/rfc822-headers")) || (str.equals("text/parityfec"));
  }
  
  private boolean isCharsetRequired()
  {
    String str = this.mimeInfo.getFullType();
    return (str.equals("text/sgml")) || (str.equals("text/xml")) || (str.equals("text/html")) || (str.equals("text/enriched")) || (str.equals("text/richtext")) || (str.equals("text/uri-list")) || (str.equals("text/directory")) || (str.equals("text/css")) || (str.equals("text/calendar")) || (str.equals("application/x-java-serialized-object")) || (str.equals("text/plain"));
  }
  
  private static boolean isCharsetSupported(String paramString)
  {
    try
    {
      boolean bool = Charset.isSupported(paramString);
      return bool;
    }
    catch (IllegalCharsetNameException paramString) {}
    return false;
  }
  
  private boolean isUnicodeFlavor()
  {
    return (this.representationClass != null) && ((this.representationClass.equals(Reader.class)) || (this.representationClass.equals(String.class)) || (this.representationClass.equals(CharBuffer.class)) || (this.representationClass.equals(char[].class)));
  }
  
  private static List<DataFlavor> selectBestByAlphabet(List<DataFlavor> paramList)
  {
    String[] arrayOfString = new String[paramList.size()];
    LinkedList localLinkedList = new LinkedList();
    int i = 0;
    if (i >= arrayOfString.length)
    {
      Arrays.sort(arrayOfString, String.CASE_INSENSITIVE_ORDER);
      paramList = paramList.iterator();
    }
    for (;;)
    {
      if (!paramList.hasNext())
      {
        paramList = localLinkedList;
        if (localLinkedList.isEmpty()) {
          paramList = null;
        }
        return paramList;
        arrayOfString[i] = ((DataFlavor)paramList.get(i)).getCharset();
        i += 1;
        break;
      }
      DataFlavor localDataFlavor = (DataFlavor)paramList.next();
      if (arrayOfString[0].equalsIgnoreCase(localDataFlavor.getCharset())) {
        localLinkedList.add(localDataFlavor);
      }
    }
  }
  
  private static DataFlavor selectBestByCharset(List<DataFlavor> paramList)
  {
    List localList2 = getFlavors(paramList, new String[] { "UTF-16", "UTF-8", "UTF-16BE", "UTF-16LE" });
    List localList1 = localList2;
    if (localList2 == null)
    {
      localList2 = getFlavors(paramList, new String[] { DTK.getDTK().getDefaultCharset() });
      localList1 = localList2;
      if (localList2 == null)
      {
        localList2 = getFlavors(paramList, new String[] { "US-ASCII" });
        localList1 = localList2;
        if (localList2 == null) {
          localList1 = selectBestByAlphabet(paramList);
        }
      }
    }
    if (localList1 != null)
    {
      if (localList1.size() == 1) {
        return (DataFlavor)localList1.get(0);
      }
      return selectBestFlavorWOCharset(localList1);
    }
    return null;
  }
  
  private static DataFlavor selectBestFlavorWCharset(List<DataFlavor> paramList)
  {
    List localList = getFlavors(paramList, Reader.class);
    if (localList != null) {
      return (DataFlavor)localList.get(0);
    }
    localList = getFlavors(paramList, String.class);
    if (localList != null) {
      return (DataFlavor)localList.get(0);
    }
    localList = getFlavors(paramList, CharBuffer.class);
    if (localList != null) {
      return (DataFlavor)localList.get(0);
    }
    localList = getFlavors(paramList, char[].class);
    if (localList != null) {
      return (DataFlavor)localList.get(0);
    }
    return selectBestByCharset(paramList);
  }
  
  private static DataFlavor selectBestFlavorWOCharset(List<DataFlavor> paramList)
  {
    List localList = getFlavors(paramList, InputStream.class);
    if (localList != null) {
      return (DataFlavor)localList.get(0);
    }
    localList = getFlavors(paramList, ByteBuffer.class);
    if (localList != null) {
      return (DataFlavor)localList.get(0);
    }
    localList = getFlavors(paramList, byte[].class);
    if (localList != null) {
      return (DataFlavor)localList.get(0);
    }
    return (DataFlavor)paramList.get(0);
  }
  
  public static final DataFlavor selectBestTextFlavor(DataFlavor[] paramArrayOfDataFlavor)
  {
    if (paramArrayOfDataFlavor == null) {}
    do
    {
      return null;
      paramArrayOfDataFlavor = sortTextFlavorsByType(new LinkedList(Arrays.asList(paramArrayOfDataFlavor)));
    } while (paramArrayOfDataFlavor.isEmpty());
    paramArrayOfDataFlavor = (List)paramArrayOfDataFlavor.get(0);
    if (paramArrayOfDataFlavor.size() == 1) {
      return (DataFlavor)paramArrayOfDataFlavor.get(0);
    }
    if (((DataFlavor)paramArrayOfDataFlavor.get(0)).getCharset().length() == 0) {
      return selectBestFlavorWOCharset(paramArrayOfDataFlavor);
    }
    return selectBestFlavorWCharset(paramArrayOfDataFlavor);
  }
  
  private static List<List<DataFlavor>> sortTextFlavorsByType(List<DataFlavor> paramList)
  {
    LinkedList localLinkedList = new LinkedList();
    String[] arrayOfString = sortedTextFlavors;
    int j = arrayOfString.length;
    int i = 0;
    for (;;)
    {
      if (i >= j)
      {
        if (!paramList.isEmpty()) {
          localLinkedList.addLast(paramList);
        }
        return localLinkedList;
      }
      List localList = fetchTextFlavors(paramList, arrayOfString[i]);
      if (localList != null) {
        localLinkedList.addLast(localList);
      }
      i += 1;
    }
  }
  
  protected static final Class<?> tryToLoadClass(String paramString, ClassLoader paramClassLoader)
    throws ClassNotFoundException
  {
    try
    {
      Class localClass1 = Class.forName(paramString);
      return localClass1;
    }
    catch (ClassNotFoundException localClassNotFoundException1)
    {
      try
      {
        Class localClass2 = ClassLoader.getSystemClassLoader().loadClass(paramString);
        return localClass2;
      }
      catch (ClassNotFoundException localClassNotFoundException2)
      {
        Object localObject = Thread.currentThread().getContextClassLoader();
        if (localObject != null) {
          try
          {
            localObject = ((ClassLoader)localObject).loadClass(paramString);
            return (Class<?>)localObject;
          }
          catch (ClassNotFoundException localClassNotFoundException3) {}
        }
      }
    }
    return paramClassLoader.loadClass(paramString);
  }
  
  public Object clone()
    throws CloneNotSupportedException
  {
    DataFlavor localDataFlavor = new DataFlavor();
    localDataFlavor.humanPresentableName = this.humanPresentableName;
    localDataFlavor.representationClass = this.representationClass;
    if (this.mimeInfo != null) {}
    for (MimeTypeProcessor.MimeType localMimeType = (MimeTypeProcessor.MimeType)this.mimeInfo.clone();; localMimeType = null)
    {
      localDataFlavor.mimeInfo = localMimeType;
      return localDataFlavor;
    }
  }
  
  public boolean equals(Object paramObject)
  {
    if ((paramObject == null) || (!(paramObject instanceof DataFlavor))) {
      return false;
    }
    return equals((DataFlavor)paramObject);
  }
  
  @Deprecated
  public boolean equals(String paramString)
  {
    if (paramString == null) {
      return false;
    }
    return isMimeTypeEqual(paramString);
  }
  
  public boolean equals(DataFlavor paramDataFlavor)
  {
    if (paramDataFlavor == this) {}
    do
    {
      do
      {
        return true;
        if (paramDataFlavor == null) {
          return false;
        }
        if (this.mimeInfo != null) {
          break;
        }
      } while (paramDataFlavor.mimeInfo == null);
      return false;
      if ((!this.mimeInfo.equals(paramDataFlavor.mimeInfo)) || (!this.representationClass.equals(paramDataFlavor.representationClass))) {
        return false;
      }
    } while ((!this.mimeInfo.getPrimaryType().equals("text")) || (isUnicodeFlavor()));
    String str = getCharset();
    paramDataFlavor = paramDataFlavor.getCharset();
    if ((!isCharsetSupported(str)) || (!isCharsetSupported(paramDataFlavor))) {
      return str.equalsIgnoreCase(paramDataFlavor);
    }
    return Charset.forName(str).equals(Charset.forName(paramDataFlavor));
  }
  
  public final Class<?> getDefaultRepresentationClass()
  {
    return InputStream.class;
  }
  
  public final String getDefaultRepresentationClassAsString()
  {
    return getDefaultRepresentationClass().getName();
  }
  
  public String getHumanPresentableName()
  {
    return this.humanPresentableName;
  }
  
  MimeTypeProcessor.MimeType getMimeInfo()
  {
    return this.mimeInfo;
  }
  
  public String getMimeType()
  {
    if (this.mimeInfo != null) {
      return MimeTypeProcessor.assemble(this.mimeInfo);
    }
    return null;
  }
  
  public String getParameter(String paramString)
  {
    paramString = paramString.toLowerCase();
    if (paramString.equals("humanpresentablename")) {
      return this.humanPresentableName;
    }
    if (this.mimeInfo != null) {
      return this.mimeInfo.getParameter(paramString);
    }
    return null;
  }
  
  public String getPrimaryType()
  {
    if (this.mimeInfo != null) {
      return this.mimeInfo.getPrimaryType();
    }
    return null;
  }
  
  public Reader getReaderForText(Transferable paramTransferable)
    throws UnsupportedFlavorException, IOException
  {
    paramTransferable = paramTransferable.getTransferData(this);
    if (paramTransferable == null) {
      throw new IllegalArgumentException(Messages.getString("awt.16E"));
    }
    if ((paramTransferable instanceof Reader))
    {
      paramTransferable = (Reader)paramTransferable;
      paramTransferable.reset();
      return paramTransferable;
    }
    if ((paramTransferable instanceof String)) {
      return new StringReader((String)paramTransferable);
    }
    if ((paramTransferable instanceof CharBuffer)) {
      return new CharArrayReader(((CharBuffer)paramTransferable).array());
    }
    if ((paramTransferable instanceof char[])) {
      return new CharArrayReader((char[])paramTransferable);
    }
    String str = getCharset();
    if ((paramTransferable instanceof InputStream))
    {
      paramTransferable = (InputStream)paramTransferable;
      paramTransferable.reset();
    }
    while (str.length() == 0)
    {
      return new InputStreamReader(paramTransferable);
      if ((paramTransferable instanceof ByteBuffer)) {
        paramTransferable = new ByteArrayInputStream(((ByteBuffer)paramTransferable).array());
      } else if ((paramTransferable instanceof byte[])) {
        paramTransferable = new ByteArrayInputStream((byte[])paramTransferable);
      } else {
        throw new IllegalArgumentException(Messages.getString("awt.16F"));
      }
    }
    return new InputStreamReader(paramTransferable, str);
  }
  
  public Class<?> getRepresentationClass()
  {
    return this.representationClass;
  }
  
  public String getSubType()
  {
    if (this.mimeInfo != null) {
      return this.mimeInfo.getSubType();
    }
    return null;
  }
  
  public int hashCode()
  {
    return getKeyInfo().hashCode();
  }
  
  public boolean isFlavorJavaFileListType()
  {
    return (List.class.isAssignableFrom(this.representationClass)) && (isMimeTypeEqual(javaFileListFlavor));
  }
  
  public boolean isFlavorRemoteObjectType()
  {
    return (isMimeTypeEqual("application/x-java-remote-object")) && (isRepresentationClassRemote());
  }
  
  public boolean isFlavorSerializedObjectType()
  {
    return (isMimeTypeSerializedObject()) && (isRepresentationClassSerializable());
  }
  
  public boolean isFlavorTextType()
  {
    if ((equals(stringFlavor)) || (equals(plainTextFlavor))) {}
    String str;
    do
    {
      return true;
      if ((this.mimeInfo != null) && (!this.mimeInfo.getPrimaryType().equals("text"))) {
        return false;
      }
      str = getCharset();
      if (!isByteCodeFlavor()) {
        break;
      }
    } while (str.length() == 0);
    return isCharsetSupported(str);
    return isUnicodeFlavor();
  }
  
  public boolean isMimeTypeEqual(String paramString)
  {
    try
    {
      boolean bool = this.mimeInfo.equals(MimeTypeProcessor.parse(paramString));
      return bool;
    }
    catch (IllegalArgumentException paramString) {}
    return false;
  }
  
  public final boolean isMimeTypeEqual(DataFlavor paramDataFlavor)
  {
    if (this.mimeInfo != null) {
      return this.mimeInfo.equals(paramDataFlavor.mimeInfo);
    }
    return paramDataFlavor.mimeInfo == null;
  }
  
  public boolean isMimeTypeSerializedObject()
  {
    return isMimeTypeEqual("application/x-java-serialized-object");
  }
  
  public boolean isRepresentationClassByteBuffer()
  {
    return ByteBuffer.class.isAssignableFrom(this.representationClass);
  }
  
  public boolean isRepresentationClassCharBuffer()
  {
    return CharBuffer.class.isAssignableFrom(this.representationClass);
  }
  
  public boolean isRepresentationClassInputStream()
  {
    return InputStream.class.isAssignableFrom(this.representationClass);
  }
  
  public boolean isRepresentationClassReader()
  {
    return Reader.class.isAssignableFrom(this.representationClass);
  }
  
  public boolean isRepresentationClassRemote()
  {
    return false;
  }
  
  public boolean isRepresentationClassSerializable()
  {
    return Serializable.class.isAssignableFrom(this.representationClass);
  }
  
  public boolean match(DataFlavor paramDataFlavor)
  {
    return equals(paramDataFlavor);
  }
  
  @Deprecated
  protected String normalizeMimeType(String paramString)
  {
    return paramString;
  }
  
  @Deprecated
  protected String normalizeMimeTypeParameter(String paramString1, String paramString2)
  {
    return paramString2;
  }
  
  /* Error */
  public void readExternal(java.io.ObjectInput paramObjectInput)
    throws IOException, ClassNotFoundException
  {
    // Byte code:
    //   0: aload_0
    //   1: monitorenter
    //   2: aload_0
    //   3: aload_1
    //   4: invokeinterface 529 1 0
    //   9: checkcast 62	java/lang/String
    //   12: putfield 103	myjava/awt/datatransfer/DataFlavor:humanPresentableName	Ljava/lang/String;
    //   15: aload_0
    //   16: aload_1
    //   17: invokeinterface 529 1 0
    //   22: checkcast 108	myjava/awt/datatransfer/MimeTypeProcessor$MimeType
    //   25: putfield 101	myjava/awt/datatransfer/DataFlavor:mimeInfo	Lmyjava/awt/datatransfer/MimeTypeProcessor$MimeType;
    //   28: aload_0
    //   29: getfield 101	myjava/awt/datatransfer/DataFlavor:mimeInfo	Lmyjava/awt/datatransfer/MimeTypeProcessor$MimeType;
    //   32: ifnull +24 -> 56
    //   35: aload_0
    //   36: getfield 101	myjava/awt/datatransfer/DataFlavor:mimeInfo	Lmyjava/awt/datatransfer/MimeTypeProcessor$MimeType;
    //   39: ldc 115
    //   41: invokevirtual 142	myjava/awt/datatransfer/MimeTypeProcessor$MimeType:getParameter	(Ljava/lang/String;)Ljava/lang/String;
    //   44: invokestatic 286	java/lang/Class:forName	(Ljava/lang/String;)Ljava/lang/Class;
    //   47: astore_1
    //   48: aload_0
    //   49: aload_1
    //   50: putfield 105	myjava/awt/datatransfer/DataFlavor:representationClass	Ljava/lang/Class;
    //   53: aload_0
    //   54: monitorexit
    //   55: return
    //   56: aconst_null
    //   57: astore_1
    //   58: goto -10 -> 48
    //   61: astore_1
    //   62: aload_0
    //   63: monitorexit
    //   64: aload_1
    //   65: athrow
    // Local variable table:
    //   start	length	slot	name	signature
    //   0	66	0	this	DataFlavor
    //   0	66	1	paramObjectInput	java.io.ObjectInput
    // Exception table:
    //   from	to	target	type
    //   2	48	61	finally
    //   48	53	61	finally
  }
  
  public void setHumanPresentableName(String paramString)
  {
    this.humanPresentableName = paramString;
  }
  
  public String toString()
  {
    return getClass().getName() + "[MimeType=(" + getMimeType() + ");humanPresentableName=" + this.humanPresentableName + "]";
  }
  
  public void writeExternal(ObjectOutput paramObjectOutput)
    throws IOException
  {
    try
    {
      paramObjectOutput.writeObject(this.humanPresentableName);
      paramObjectOutput.writeObject(this.mimeInfo);
      return;
    }
    finally
    {
      paramObjectOutput = finally;
      throw paramObjectOutput;
    }
  }
}


/* Location:              /home/enzo/Documents/BorelEnzo.github.io/malwares/dsencrypt/classes.jar!/myjava/awt/datatransfer/DataFlavor.class
 * Java compiler version: 6 (50.0)
 * JD-Core Version:       0.7.1
 */